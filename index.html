<!DOCTYPE html>
<html>
  <head>
    <title>Heart WebAR</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.min.js"></script>
    <style>
      body { margin: 0; overflow: hidden; }
      #startOverlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.9); z-index: 9999;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        color: white; text-align: center;
      }
      button {
        margin-top: 20px; padding: 15px 30px; font-size: 18px;
        background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;
      }
      #uiPanel {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 10;
        background: rgba(255, 255, 255, 0.85);
        padding: 10px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        pointer-events: auto;
      }
      #uiPanel button {
        display: block;
        margin-bottom: 10px;
        padding: 10px 20px;
        font-size: 14px;
        cursor: pointer;
      }
      #togglePanel {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 11;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        font-size: 24px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <!-- Start Overlay -->
    <div id="startOverlay">
      <h2>Start Heart AR Experience</h2>
      <button id="startButton">Start</button>
    </div>

    <!-- UI Toggle -->
    <button id="togglePanel" onclick="togglePanel()">â˜°</button>

    <!-- UI Panel -->
    <div id="uiPanel">
      <button onclick="setMode('marker')">Use Marker</button>
      <button onclick="setMode('markerless')">Place in Space</button>
      <button onclick="resetScene()">Reset</button>
    </div>

    <!-- Scene -->
    <a-scene
      embedded
      tap-place
      arjs="sourceType: webcam; debugUIEnabled: false; cameraParametersUrl: camera_para.dat"
    >
      <a-assets>
        <audio id="beepSound" src="audio/beep.mp3" preload="auto"></audio>
        <a-asset-item id="heartGLB" src="body.glb"></a-asset-item>
      </a-assets>

      <!-- Marker-based -->
      <a-marker preset="hiro" id="marker" emitevents="true">
        <a-entity
          id="markerHeart"
          visible="false"
          gltf-model="#heartGLB"
          scale="0.03 0.03 0.03"
          add-labels-on-load
          drag-rotate
        ></a-entity>
      </a-marker>

      <!-- Markerless -->
      <a-entity
        id="placedHeart"
        visible="false"
        gltf-model="#heartGLB"
        scale="0.03 0.03 0.03"
        add-labels-on-load
        drag-rotate
      ></a-entity>

      <!-- Audio -->
      <a-sound id="heartSound" src="#beepSound" autoplay="false"></a-sound>
      <a-sound id="aortaAudio" src="audio/aorta.mp3" preload="auto" autoplay="false"></a-sound>
      <a-sound id="ventricleAudio" src="audio/ventricle.mp3" preload="auto" autoplay="false"></a-sound>

      <!-- Camera -->
      <a-entity camera cursor="rayOrigin: mouse" raycaster="objects: .clickable"></a-entity>
    </a-scene>

    <script>
      let mode = null;
      let placingEnabled = false;

      function setMode(selectedMode) {
        mode = selectedMode;
        document.getElementById('markerHeart').setAttribute('visible', false);
        document.getElementById('placedHeart').setAttribute('visible', false);

        if (mode === 'marker') {
          alert('Point your camera at the marker.');
          placingEnabled = false;
        } else if (mode === 'markerless') {
          alert('Tap to place the heart.');
          placingEnabled = true;
        }
      }

      function togglePanel() {
        const panel = document.getElementById('uiPanel');
        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
      }

      document.getElementById('startButton').addEventListener('click', function () {
        document.getElementById('startOverlay').style.display = 'none';

        const audios = document.querySelectorAll('audio');
        audios.forEach(audio => {
          audio.play().then(() => {
            audio.pause();
            audio.currentTime = 0;
          }).catch(err => {
            console.warn('Autoplay unlock failed:', err);
          });
        });
      });

      // Marker show/hide
      const marker = document.querySelector('#marker');
      marker.addEventListener('markerFound', () => {
        if (mode === 'marker') {
          document.getElementById('markerHeart').setAttribute('visible', true);
        }
      });
      marker.addEventListener('markerLost', () => {
        document.getElementById('markerHeart').setAttribute('visible', false);
      });

      // Tap-place logic
      AFRAME.registerComponent('tap-place', {
        init: function () {
          const scene = this.el.sceneEl;
          const placedHeart = document.getElementById('placedHeart');

          const placeHeart = (event) => {
            if (mode !== 'markerless' || !placingEnabled) return;

            const touch = event.touches ? event.touches[0] : event;
            const mouse = new THREE.Vector2(
              (touch.clientX / window.innerWidth) * 2 - 1,
              -(touch.clientY / window.innerHeight) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, scene.camera);

            const direction = raycaster.ray.direction.clone().normalize();
            const position = raycaster.ray.origin.clone().add(direction.multiplyScalar(1.5));

            placedHeart.setAttribute('position', position);
            placedHeart.setAttribute('visible', true);
            placingEnabled = false;
          };

          scene.addEventListener('click', placeHeart);
          scene.addEventListener('touchstart', placeHeart);
        }
      });

      function resetScene() {
        const markerHeart = document.getElementById('markerHeart');
        const placedHeart = document.getElementById('placedHeart');

        [markerHeart, placedHeart].forEach(model => {
          model.setAttribute('visible', false);
          model.setAttribute('position', '0 0 0');
          model.setAttribute('rotation', '0 0 0');
          model.setAttribute('scale', '0.03 0.03 0.03');
        });

        if (mode === 'markerless') {
          placingEnabled = true;
          alert('Tap to place the heart again.');
        }
      }

      AFRAME.registerComponent('add-labels-on-load', {
        init: function () {
          this.el.addEventListener('model-loaded', () => {
            this.el.setAttribute('add-labels', '');
          });
        }
      });

      AFRAME.registerComponent('face-camera', {
        tick: function () {
          const cameraPosition = this.el.sceneEl.camera.el.object3D.position;
          this.el.object3D.lookAt(cameraPosition);
        }
      });

      AFRAME.registerComponent('add-labels', {
  init: function () {
    if (this.el.dataset.labelsAdded) return;
    this.el.dataset.labelsAdded = true;

    const parts = [
      { name: 'Stomach', position: { x: 0.1, y: 0.25, z: 0.1 }, audioId: 'aortaAudio' },
      { name: 'Liver', position: { x: 3, y: 1, z: -9 }, audioId: 'ventricleAudio' }
    ];

    parts.forEach((part) => {
      const textEntity = document.createElement('a-entity');
      textEntity.setAttribute('text', {
        value: part.name,
        align: 'center',
        width: 2,
        color: '#000'
      });
      textEntity.setAttribute('position', '0 0 0.01');

      const labelPlane = document.createElement('a-plane');
      labelPlane.setAttribute('width', 1.5);
      labelPlane.setAttribute('height', 0.5);
      labelPlane.setAttribute('material', { color: '#fff', opacity: 0.9 });
      labelPlane.setAttribute('position', part.position);
      labelPlane.setAttribute('class', 'clickable');
      labelPlane.setAttribute('play-audio-on-click', `audioId: ${part.audioId}`);
      labelPlane.setAttribute('face-camera', '');

      labelPlane.appendChild(textEntity);
      this.el.appendChild(labelPlane);
    });
  }
});


      AFRAME.registerComponent('play-audio-on-click', {
  schema: { audioId: { type: 'string' } },
  init: function () {
    this.el.addEventListener('click', () => {
      const audio = document.querySelector(`#${this.data.audioId}`);
      if (audio && audio.components && audio.components.sound) {
        audio.components.sound.playSound();
      } else {
        console.warn(`Audio component not ready or missing: #${this.data.audioId}`);
      }
    });
  }
});


      AFRAME.registerComponent('drag-rotate', {
        schema: {
          speed: { default: 0.15 },
          zoomSpeed: { default: 0.0008 },
          panSpeed: { default: 0.0015 }
        },
        init: function () {
          this.isDragging = false;
          this.previousPosition = null;
          this.scale = 1;
          this.pan = { x: 0, y: 0 };
          this.rotation = { x: 0, y: 0 };
          this.el.setAttribute('rotation', this.rotation);

          const el = this.el;
          const scene = el.sceneEl;

          scene.addEventListener('mousedown', (e) => {
            this.isDragging = true;
            this.previousPosition = { x: e.clientX, y: e.clientY };
          });
          window.addEventListener('mouseup', () => { this.isDragging = false; });
          scene.addEventListener('mousemove', (e) => {
            if (!this.isDragging) return;
            const dx = e.clientX - this.previousPosition.x;
            const dy = e.clientY - this.previousPosition.y;
            this.rotation.y -= dx * this.data.speed;
            this.rotation.x -= dy * this.data.speed;
            el.setAttribute('rotation', this.rotation);
            this.previousPosition = { x: e.clientX, y: e.clientY };
          });

          scene.addEventListener('wheel', (e) => {
            e.preventDefault();
            this.scale += -e.deltaY * this.data.zoomSpeed;
            this.scale = Math.max(0.001, Math.min(5, this.scale));
            el.setAttribute('scale', `${this.scale} ${this.scale} ${this.scale}`);
          });

          scene.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
              this.isDragging = true;
              this.previousPosition = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY
              };
            } else if (e.touches.length === 2) {
              this.isDragging = false;
              this.initialPinchDistance = this.getPinchDistance(e);
              this.initialScale = this.scale;
              this.previousPan = this.getMidpoint(e);
            }
          });

          scene.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1 && this.isDragging) {
              const dx = e.touches[0].clientX - this.previousPosition.x;
              const dy = e.touches[0].clientY - this.previousPosition.y;
              this.rotation.y -= dx * this.data.speed;
              this.rotation.x -= dy * this.data.speed;
              el.setAttribute('rotation', this.rotation);
              this.previousPosition = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY
              };
            } else if (e.touches.length === 2) {
              const newDistance = this.getPinchDistance(e);
              const scaleChange = newDistance / this.initialPinchDistance;
              this.scale = this.initialScale * scaleChange;
              this.scale = Math.max(0.001, Math.min(5, this.scale));
              el.setAttribute('scale', `${this.scale} ${this.scale} ${this.scale}`);

              const newMid = this.getMidpoint(e);
              const dx = (newMid.x - this.previousPan.x) * this.data.panSpeed;
              const dy = -(newMid.y - this.previousPan.y) * this.data.panSpeed;
              this.pan.x += dx;
              this.pan.y += dy;
              el.setAttribute('position', { x: this.pan.x, y: this.pan.y, z: 0 });
              this.previousPan = newMid;
            }
          });

          scene.addEventListener('touchend', () => {
            this.isDragging = false;
          });
        },
        getPinchDistance: function (e) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          return Math.sqrt(dx * dx + dy * dy);
        },
        getMidpoint: function (e) {
          return {
            x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
            y: (e.touches[0].clientY + e.touches[1].clientY) / 2
          };
        }
      });
    </script>
  </body>
</html>
