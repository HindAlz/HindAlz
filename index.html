<!DOCTYPE html>
<html>
  <head>
    <title>Heart & Body AR</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.min.js"></script>
    <style>
      body { margin: 0; overflow: hidden; touch-action: none; }
      a-scene { position: absolute; width: 100%; height: 100%; }
    </style>
  </head>

  <body>
    <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false;" vr-mode-ui="enabled: false">
      <a-assets>
        <audio id="aortaAudio" src="audio/aorta.mp3" preload="auto"></audio>
        <audio id="liverAudio" src="audio/aorta.mp3" preload="auto"></audio>
        <a-asset-item id="bodyGLB" src="body.glb"></a-asset-item>
        <a-asset-item id="heartGLB" src="heart.glb"></a-asset-item>
      </a-assets>

      <!-- Lighting -->
      <a-entity light="type: ambient; intensity: 1.2"></a-entity>
      <a-entity light="type: directional; intensity: 0.6" position="1 2 1"></a-entity>

      <!-- Marker: Body -->
      <a-marker type="pattern" url="marker.patt" emitevents="true">
        <a-entity 
          gltf-model="#bodyGLB" 
          scale="0.05 0.05 0.05" 
          rotation="-90 0 0" 
          zoom-rotate 
          add-body-labels>
        </a-entity>
      </a-marker>

      <!-- Marker: Heart -->
      <a-marker type="pattern" url="heart-marker.patt" emitevents="true">
        <a-entity 
          gltf-model="#heartGLB" 
          scale="0.5 0.5 0.5" 
          rotation="-90 0 0" 
          zoom-rotate 
          add-heart-labels>
        </a-entity>
      </a-marker>

      <a-entity camera></a-entity>
    </a-scene>

    <script>
      AFRAME.registerComponent('add-body-labels', {
        init: function () {
          const label = document.createElement('a-entity');
          label.setAttribute('geometry', 'primitive: plane; height: 0.5; width: 2');
          label.setAttribute('material', 'color: green; opacity: 0.7');
          label.setAttribute('text', 'value: Liver; align: center; color: white; width: 4');
          label.setAttribute('position', '0 1 0');
          label.setAttribute('class', 'clickable');
          label.setAttribute('play-audio-on-click', 'audioId: liverAudio');
          this.el.appendChild(label);
        }
      });

      AFRAME.registerComponent('add-heart-labels', {
        init: function () {
          const label = document.createElement('a-entity');
          label.setAttribute('geometry', 'primitive: plane; height: 0.5; width: 2');
          label.setAttribute('material', 'color: blue; opacity: 0.7');
          label.setAttribute('text', 'value: Aorta; align: center; color: white; width: 4');
          label.setAttribute('position', '0 1 0');
          label.setAttribute('class', 'clickable');
          label.setAttribute('play-audio-on-click', 'audioId: aortaAudio');
          this.el.appendChild(label);
        }
      });

      AFRAME.registerComponent('play-audio-on-click', {
        schema: { audioId: { type: 'string' } },
        init: function () {
          this.el.addEventListener('click', () => {
            const audio = document.querySelector(`#${this.data.audioId}`);
            if (audio) {
              audio.play().catch(e => console.log('Audio play blocked:', e));
            }
          });
        }
      });

      AFRAME.registerComponent('zoom-rotate', {
        init: function () {
          let el = this.el;
          let isDragging = false, prevX = 0;
          let initialPinchDistance = null;

          const getDistance = (touches) => {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
          };

          const onTouchStart = (e) => {
            if (e.touches.length === 1) {
              isDragging = true;
              prevX = e.touches[0].clientX;
            } else if (e.touches.length === 2) {
              initialPinchDistance = getDistance(e.touches);
            }
          };

          const onTouchMove = (e) => {
            if (e.touches.length === 1 && isDragging) {
              const dx = e.touches[0].clientX - prevX;
              prevX = e.touches[0].clientX;
              const rot = el.getAttribute('rotation');
              rot.y += dx * 0.5;
              el.setAttribute('rotation', rot);
            } else if (e.touches.length === 2) {
              const newDist = getDistance(e.touches);
              if (initialPinchDistance) {
                const scale = el.getAttribute('scale');
                const factor = newDist / initialPinchDistance;
                const newScale = {
                  x: Math.max(0.01, scale.x * factor),
                  y: Math.max(0.01, scale.y * factor),
                  z: Math.max(0.01, scale.z * factor)
                };
                el.setAttribute('scale', newScale);
                initialPinchDistance = newDist;
              }
            }
          };

          const onTouchEnd = () => {
            isDragging = false;
            initialPinchDistance = null;
          };

          document.addEventListener('touchstart', onTouchStart);
          document.addEventListener('touchmove', onTouchMove);
          document.addEventListener('touchend', onTouchEnd);
        }
      });
    </script>
  </body>
</html>
